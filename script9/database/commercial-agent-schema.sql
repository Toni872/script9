-- ============================================
-- COMMERCIAL AI AGENT SCHEMA - SCRIPT9
-- ============================================

-- Enable pgvector for RAG
CREATE EXTENSION IF NOT EXISTS vector;

-- 1. CRM LEADS
-- Captures potential clients from various sources (WhatsApp, Web, Email)
CREATE TABLE IF NOT EXISTS crm_leads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT,
    email TEXT,
    phone TEXT,
    company TEXT,
    source TEXT DEFAULT 'web', -- 'web', 'whatsapp', 'email'
    status TEXT DEFAULT 'new', -- 'new', 'contacted', 'qualified', 'converted', 'lost'
    notes TEXT,
    last_contact_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL -- Link to registered user if matched
);

-- 2. CRM QUOTES
-- Budget proposals generated by the AI
CREATE TABLE IF NOT EXISTS crm_quotes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID REFERENCES crm_leads(id) ON DELETE CASCADE,
    services JSONB, -- Array of items: [{ service: 'Chatbot', price: 500 }, ...]
    total_amount NUMERIC,
    currency TEXT DEFAULT 'EUR',
    status TEXT DEFAULT 'draft', -- 'draft', 'sent', 'accepted', 'rejected'
    valid_until TIMESTAMPTZ,
    pdf_url TEXT, -- Link to generated PDF if any
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. AGENT CONVERSATIONS
-- Flexible conversations not tied to bookings
CREATE TABLE IF NOT EXISTS agent_conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lead_id UUID REFERENCES crm_leads(id) ON DELETE SET NULL,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    channel TEXT DEFAULT 'web_chat', -- 'web_chat', 'whatsapp', 'email'
    channel_thread_id TEXT, -- External ID (e.g., WA phone number context)
    status TEXT DEFAULT 'active', -- 'active', 'closed', 'handoff_to_human'
    subject TEXT,
    summary TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. AGENT MESSAGES
CREATE TABLE IF NOT EXISTS agent_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id UUID REFERENCES agent_conversations(id) ON DELETE CASCADE NOT NULL,
    role TEXT NOT NULL, -- 'user', 'assistant', 'system', 'function'
    content TEXT,
    tool_calls JSONB, -- If AI calls a tool
    tool_call_id TEXT, -- If this message is a tool result
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 5. KNOWLEDGE BASE (RAG)
CREATE TABLE IF NOT EXISTS knowledge_base (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content TEXT NOT NULL, -- The actual text chunk
    metadata JSONB, -- Source info, tags, etc.
    embedding vector(1536), -- OpenAI embedding size
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- INDEXES
CREATE INDEX IF NOT EXISTS idx_leads_email ON crm_leads(email);
CREATE INDEX IF NOT EXISTS idx_leads_phone ON crm_leads(phone);
CREATE INDEX IF NOT EXISTS idx_quotes_lead ON crm_quotes(lead_id);
CREATE INDEX IF NOT EXISTS idx_agent_conv_lead ON agent_conversations(lead_id);
CREATE INDEX IF NOT EXISTS idx_agent_msgs_conv ON agent_messages(conversation_id);

-- RLS POLICIES (Preliminary - Open for Admin/Service Role)
ALTER TABLE crm_leads ENABLE ROW LEVEL SECURITY;
ALTER TABLE crm_quotes ENABLE ROW LEVEL SECURITY;
ALTER TABLE agent_conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE agent_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE knowledge_base ENABLE ROW LEVEL SECURITY;

-- Allow public insert for leads/convos (for the web widget to work for visitors)
-- In a real prod setup, we'd limit this or use a service key for the API.
-- For now, let's assume the API uses Service Role to write new leads.
-- Authenticated users policies:
CREATE POLICY "Admins can view all" ON crm_leads FOR ALL USING (auth.role() = 'authenticated'); 
-- (Refine this later based on actual Admin role implementation)

-- Create a function to search documents
CREATE OR REPLACE FUNCTION match_documents (
  query_embedding vector(1536),
  match_threshold float,
  match_count int
)
RETURNS TABLE (
  id uuid,
  content text,
  metadata jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    knowledge_base.id,
    knowledge_base.content,
    knowledge_base.metadata,
    1 - (knowledge_base.embedding <=> query_embedding) as similarity
  FROM knowledge_base
  WHERE 1 - (knowledge_base.embedding <=> query_embedding) > match_threshold
  ORDER BY similarity DESC
  LIMIT match_count;
END;
$$;
