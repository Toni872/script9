import { NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js'; // Use admin client for seeding
import { mockServices } from '@/lib/mockData';

// CREATE ADMIN CLIENT DIRECTLY FOR SEEDING (Bypasses RLS)
const supabaseAdmin = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
        auth: {
            autoRefreshToken: false,
            persistSession: false
        }
    }
);

export async function GET() {
    try {
        console.log('Starting seed process...');

        // 1. Get a valid user to assign as host
        const { data: users, error: userError } = await supabaseAdmin
            .from('users')
            .select('id')
            .limit(1);

        if (userError || !users || users.length === 0) {
            return NextResponse.json({ error: 'No users found to assign as host. Please sign up first.' }, { status: 400 });
        }

        const hostId = users[0].id;

        // 2. Iterate and Insert
        const results = [];

        for (const service of mockServices) {
            // Check if title exists to avoid dupes (rough check)
            const { data: existing } = await supabaseAdmin
                .from('properties')
                .select('id')
                .eq('title', service.title)
                .single();

            let serviceId = existing?.id;

            if (!serviceId) {
                // Insert new property
                const { data: newService, error: insertError } = await supabaseAdmin
                    .from('properties')
                    .insert({
                        // ID: Auto-generated by DB (UUID)
                        title: service.title,
                        description: service.description,
                        price_per_hour: service.price,
                        price_per_day: service.price, // Fix: Populate required price_per_day field
                        max_guests: 100, // Arbitrary high number for unlimited capacity
                        host_id: hostId,
                        property_type: service.property_type,
                        is_script9_select: true,
                        city: 'Global',
                        address: 'Cloud',

                        region: 'Internet',
                        location: 'POINT(0 0)', // Fix: Use WKT format for Geometry column
                        latitude: 0,
                        longitude: 0,
                    })
                    .select()
                    .single();

                if (insertError) {
                    console.error('Error inserting service:', insertError);
                    results.push({ title: service.title, status: 'error', error: insertError.message });
                    continue;
                }
                serviceId = newService.id;
                results.push({ title: service.title, status: 'created', id: serviceId });
            } else {
                results.push({ title: service.title, status: 'skipped (exists)', id: serviceId });
            }

            // 3. Insert Features
            if (service.features) {
                // Clear existing
                await supabaseAdmin.from('property_features').delete().eq('property_id', serviceId);

                // Add new
                const features = service.features.map((f: any) => ({
                    property_id: serviceId,
                    feature: f.name
                }));
                await supabaseAdmin.from('property_features').insert(features);
            }

            // 4. Insert Images
            if (service.image_urls) {
                // Clear existing
                await supabaseAdmin.from('property_images').delete().eq('property_id', serviceId);

                const images = service.image_urls.map((url: string, index: number) => ({
                    property_id: serviceId,
                    image_url: url,
                    is_primary: index === 0
                }));
                await supabaseAdmin.from('property_images').insert(images);
            }
        }

        return NextResponse.json({ success: true, results });

    } catch (error: any) {
        console.error('Seed error:', error);
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}
